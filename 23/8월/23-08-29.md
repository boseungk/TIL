## MySQL 기본 실행 계획 항목 분석

```SQL
mysql> EXPLAIN SELECT * FROM 사원 WHERE 사원번호 BETWEEN 100001 AND 200000;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 20080 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
```

* type
  * 테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공하는 항목
  * system
    * 테이블에 데이터가 없거나 한 개만 있는 경우로, 성능상 최상의 type
  * const
    * 조회되는 데이터가 단 1건일 때 출력되는 유형
  * eq_ref
    * 조인이 수행될 때 드리븐 테이블에 접근하면서 인덱스나 기본 키로 단 1건의 데이터만 조회하는 방식
    * 조인이 수행될 때 성능상 가장 유리한 경우
  * ref
    * 조인이 수행될 때 드리븐 테이블의 접근 범위가 2개 이상인 경우
  * ref_or_null
    * ref와 유사하며, IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식
    * MySQL은 NULL에 대해서도 인덱스 적용이 가능하며 NULL은 가장 앞쪽에 정렬된다.
  * index_merge
    * 인덱스들이 동시에 사용되는 타입으로 특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용
  * index
    * 인덱스 풀 스캔, 즉 인덱스 블록을 처음부터 끝까지 훑는 방식
  * ALL
    * 테이블을 처음부터 끝까지 읽는 테이블 풀 스캔 방식
    * 활용할 수 있는 인덱스가 없거나 인덱스를 활용하는 게 더 비효율적이라고 옵티마이저가 판단했을 경우 사용
* filtered
  * SQL 문을 통해 DB 엔진으로 가져온 데이터에서 필터 조건에 따라 어느 정도의 비율로 데이터를 제거했는지 의미하는 타입
  * 예를 들어 100건을 가져와서 WHERE조건으로 10건만 필터링 해서 조회한다면 10%