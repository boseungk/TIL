## 알고리즘

### 물체 단위로 완전탐색 / 개발자의 순위

K번의 경기에 대해 N명의 개발자의 순위가 주어졌을 때, 항상 a번 개발자가 b번 개발자보다 더 높은 순위였던 서로 다른 (a, b) 쌍의 수를 구하는 프로그램을 작성해보세요.

입력 형식
첫 번째 줄에는 K와 N이 공백을 사이에 두고 주어집니다.

두 번째 줄부터는 K개의 줄에 걸쳐 각 경기에 대한 결과인 N개의 정수값이 공백을 사이에 두고 주어집니다. 이 숫자는 각각의 개발자 번호를 의미하며, 먼저 입력으로 주어진 개발자의 순위가 더 높았음을 의미합니다. 한 경기에 대해 1부터 N까지의 숫자가 겹치지 않고 주어짐을 가정해도 좋습니다.

1 ≤ K ≤ 10
1 ≤ N ≤ 20
출력 형식
첫 번째 줄에는 불변의 순위에 대해 서로 다른 (a, b) 쌍의 수를 출력합니다.

입출력 예제
예제1
입력:
```java
3 4
4 1 2 3
4 1 3 2
4 2 1 3
```

출력:
```java
4
```

예제 설명
다음 4개의 쌍이 존재합니다.

(4, 1) - 4번 개발자는 3번의 경기에 있어 1번 개발자보다 항상 순위가 높았습니다.

(4, 2) - 4번 개발자는 3번의 경기에 있어 2번 개발자보다 항상 순위가 높았습니다.

(4, 3) - 4번 개발자는 3번의 경기에 있어 3번 개발자보다 항상 순위가 높았습니다.

(1, 3) - 1번 개발자는 3번의 경기에 있어 3번 개발자보다 항상 순위가 높았습니다.

### 해설

문제 자체는 사실 간단 했는데, 구현하다가 계속 뇌정지가 왔다..

한 줄에서 인덱스 두 개로 탐색하다가 다음 행으로 넘어가서 또 인덱스 두 개로 탐색해서 같은 것 찾기.. 이런 식으로 해석했는데 뭔가 for문이 계속 중첩해서 나오니까 인덱스 변수가 뭘 의미하는지도 헷갈려서 푸는데 한참 걸렸다.

그래서 구현 연습으로는 나쁘지 않았던 것 같다.

### 해답

```java
import java.util.*;
public class Main {
    static int k, n;
    static int[][] arr = new int[10][20];
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        k = sc.nextInt();
        n = sc.nextInt();
        for(int i=0; i<k; i++){
            for(int j=0; j<n; j++){
                arr[i][j] = sc.nextInt();
            }
        }
        int result = 0;
        for(int i=0; i<n; i++){
            int[] tmp = new int[2];
            for(int j=i+1; j<n; j++){
                tmp[0] = arr[0][i];
                tmp[1] = arr[0][j];
                int count = 0;
                for(int p=0; p<k; p++){
                    for(int k=0; k<n; k++){
                        for(int l=k+1; l<n; l++){
                            if(tmp[0] == arr[p][k] && tmp[1] == arr[p][l]){
                                count++;
                            }
                        }
                    }
                }
            if(count == k)
                result++;
            }
            
        }
        System.out.println(result);
    }
}
```