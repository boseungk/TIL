## 알고리즘

### 기준을 새로 설정하여 완전탐색 / 독서실의 거리두기 5

신종 전염병이 퍼짐으로써 리브로스 독서실은 이용자들의 좌석 간의 거리를 두려고 합니다. 새로 한 명을 더 받으려고 하는데, 현재 있는 사람들은 원래 있던 자리에 그대로 두고 최대한 거리를 두면서 자리배치를 해주려고 합니다. 여기서 거리라 함은, 두 사람이 몇 칸 떨어져 있는지를 의미합니다. 리브로스 독서실에 있는 모든 좌석의 개수가 N개이고, 현재 좌석의 공석 여부가 주어지면, 한 명의 인원을 배치한 후 최대한의 거리두기를 실행한 간격을 출력하는 프로그램을 작성해보세요. 최대한의 거리두기를 한다는 것은, 한 명을 더 집어넣었을 때 가장 가까운 두 사람 간의 거리를 최대로 하고 싶다는 뜻입니다.

입력 형식
첫 번째 줄에 좌석의 개수 N을 출력합니다.

두 번째 줄에 길이가 N이며 ‘0'과 ‘1’로만 이루어진 문자열이 하나 주어집니다. N개의 좌석 중 ‘0’인 곳은 비어있음을, '1’인 곳은 이미 차 있음을 뜻합니다. 처음 최소 한 개 이상의 '1'이 주어짐을 가정해도 좋습니다.

2 ≤ N ≤ 20
출력 형식
첫 번째 줄에 가능한 가장 가까운 두 사람의 거리의 최댓값을 출력합니다.

입출력 예제
예제1
입력:
```java
13
1000100100010
```

출력:
```java
2
```

예제2
입력:

```java
14
10000000100000
```

출력:

```java
5
```

예제 설명
첫 번째 예제에서는 한 명의 인원이 들어갈 만한 공간을 x라 칭해보면, 다음 2가지 경우에 대해서는 가장 가까운 두 사람의 거리를 2로 만들 수 있습니다. 이보다 더 크게 만들 수는 없습니다.

10x0100100010
   
100010010x010

두 번째 예제에서는 크게 다음 2가지 경우를 생각해볼 수 있습니다.

다음과 같이 1과 1 사이 중 가운데에 사람을 추가하게 되는 경우라면, 가장 가까운 두 사람의 거리가 4가 됩니다.

1000x000100000

하지만 가장 오른쪽에 사람을 추가하게 되면, 가장 가까운 두 사람의 거리가 5가 되므로 최대가 됩니다. 이보다 더 좋게 만들 수는 없습니다.

1000000010000x

### 해설

먼저 완전탐색 문제인 것을 확인했다면, 일단 어떤 값이 변수인지 찾아보자. 그 후 변수를 기준으로 가장 단순하게 해당 변수만을 바꿔서 새로 모든 경우의 수를 따지는 것 먼저 고려해보자. 이렇게 풀리지 않는다면 케이스를 나누는 것을 고려해보자.

### 해답

```java
import java.util.*;
public class Main {
    static int n;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        char[] seat = sc.next().toCharArray();
        int max = Integer.MIN_VALUE;
        for(int i=0; i<n; i++){
            if(seat[i] == '1') continue;
            seat[i] = '1';
            int min = Integer.MAX_VALUE;
            for(int j=0; j<n; j++){
                for(int k=j+1; k<n; k++){
                    if(seat[j] == '1' && seat[k] == '1'){
                        min = Math.min(min, k - j);
                    }
                }
            }
            max = Math.max(max, min);
            seat[i] = '0';
        }
        System.out.println(max);
    }
}
```

### 값을 기준으로 완전탐색 / 빙산의 일각 2

해수면의 높이에 따라 물에 잠기는 빙산들이 있습니다. 빙산의 개수 N이 주어지고 N개의 빙산들의 높이 H(i)가 순서대로 주어집니다. 빙산들이 물에 잠기지 않은 채로 붙어있는 경우를 한 덩어리로 볼 때, 해수면의 높이를 적절하게 설정 했을 때 가능한 빙산 덩어리의 최대 개수를 구하는 프로그램을 아래 예를 참고하여 작성해보세요

입력 형식
첫 번째 줄에 빙산들의 개수 N이 주어지고

두 번째 줄부터 N개의 줄에 걸쳐 빙산의 높이 H(i)가 순서대로 한 줄에 하나씩 주어집니다.

1 ≤ N ≤ 100
1 ≤ H(i) ≤ 1,000
출력 형식
첫 번째 줄에 해당하는 값을 출력합니다.

입출력 예제
예제1
입력:
```java
9
3
5
2
3
2
1
4
2
3
```

출력:

```java
4
```

### 해설

카운트 하는 경우의 수가 앞에서 카운트하거나 뒤에서 카운트하는 방법 2가지가 있었다.

사실 둘 다 비슷할 꺼라고 가정하고 더 편한 방법을 선택해서 풀었는데, 계속 1개 정도 차이로 카운트가 잘못 되었다.

알고보니까 각 케이스에 따라 예외 처리 난이도가 많이 달라졌다..

따라서 예외 처리가 더 쉬울 거 같은 케이스를 선택해서 알고리즘을 정해야 한다!

또 문제로 주어진 테스트 케이스는 전부 통과하는지 print로 찍어서 최소한의 확인은 해보자.

### 해답

```java
import java.util.*;
public class Main {
    static int n;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        int[] heights = new int[n];
        int maxN = Integer.MIN_VALUE;
        for(int i=0; i<n; i++){
            heights[i] = sc.nextInt();
            maxN = Math.max(maxN, heights[i]);
        }
        int max = Integer.MIN_VALUE;
        for(int i=1; i<=maxN; i++){
            int count = 0;
            if(heights[0] > i) count++;
            for(int j=1; j<n; j++){
                if(heights[j-1] <= i && heights[j] > i)
                    count++;
            }
            max = Math.max(max, count);
        }
        System.out.println(max);
    }
}
```
