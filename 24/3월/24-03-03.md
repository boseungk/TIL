## 알고리즘

### String Matching / 최장 공통 부분 수열

다음과 같이 2개의 문자열이 주어졌을 때, 두 문자열을 모두 부분 문자열로 하는 문자열 중 길이가 가장 짧은 문자열을 구해보려 합니다. 이러한 문자열을 최단 공통 supersequence라 부릅니다. 다음 예에서의 최단 공통 supersequence는 SABASBA가 됩니다.



아래 그림에서 상단의 경우는 첫 번째 문자열의 1, 2, 4 번째 문자를 선택하고, 두 번째 문자열의 2, 3, 4번째를 선택하여 최단 공통 supersequence의 길이가 7이 되었고, 앞으로 6번째 문자부터 추가적으로 공통 supersequence를 추가하려고 하는 상황입니다. 하단의 경우는 첫 번째 문자열의 2, 3, 4 번째 문자를 선택하고, 두 번째 문자열의 1, 3, 4번째를 선택하여 최단 공통 supersequence의 길이가 7이 되었고, 앞으로 6번째 문자부터 추가적으로 공통 supersequence를 추가하려고 하는 상황입니다.



이러한 상황에서 앞으로 문자열의 6번째 문자부터 적절히 잘 선택해 첫 번째와 두 번째 문자열의 최단 공통 supersequence을 최대가 되도록 만드려는 관점에서 보았을 때, 앞의 두 상황은 동등한 상황이라고 생각할 수 있습니다. 왜냐하면 해당 문제에서는 ‘마지막으로 고려된 부분 문자열’과 '공통 supersequence의 길이’가 일치하는 경우, 그 이후의 입장에서 보았을 때 동일한 상황으로 간주할 수 있기 때문입니다.

즉 이 문제에서는 다음의 세 가지가 일치하는 경우, 그 이후의 입장에서 보았을 때 동일한 상황으로 간주할 수 있습니다.

지금까지 고려한 첫 번째 문자열의 위치

지금까지 고려한 두 번째 문자열의 위치

지금까지 고려된 두 부분 문자열의 공통 supersequence의 길이



따라서 이 문제를 다음과 같이 해석해 볼 수 있습니다.

지금까지 고려한 ‘첫 번째 문자열의 위치’와 ‘두 번째의 문자열의 위치’가 같다면, 지금까지 고려된 ‘두 부분 문자열의 공통 supersequence의 길이’는 짧을수록 더 좋다.


해당 솔루션에서는 이러한 특징을 이용해 점화식을 세워 문제를 해결해보도록 하겠습니다. 이 때 dp[i][j]에 대한 정의를 ‘첫 번째 문자열의 i번째 문자까지 고려하고, 두 번째 문자열의 j번째 문자까지 고려했을 때 가능한 공통 supersequence의 최단 길이’라고 해봅시다.



그렇다면 dp[i][j] 값을 구하기 위해서는 다음의 2가지를 고려해 봐야 합니다.

첫 번째 문자열의 i번째 문자와, 두 번째 문자열 j번째 문자가 일치하는 경우
이 경우 해당 문자를 공통 supersequence에 포함시키게 되면 첫 번째 문자열에서 i-1번째 문자까지 고려하고, 두 번째 문자열의 j-1번째 문자까지 고려했을 때 가능한 공통 supersequence의 뒤에 문자 하나를 새로 추가할 수 있게 됩니다. 따라서 dp[i-1][j-1]에 1을 추가해주면 됩니다.



첫 번째 문자열의 i번째 문자와, 두 번째 문자열 j번째 문자가 일치하지 않는 경우
해당 경우에는 다음 2가지를 고민해 볼 수 있습니다

첫 번째 문자열의 i 번째 문자를 두 번째 문자열과 공통으로 묶어 처리하지 않을 경우 : dp[i-1][j] 값을 사용해주면 됩니다.

두 번째 문자열의 j 번째 문자를 첫 번째 문자열과 공통으로 묶어 처리하지 않을 경우 : dp[i][j-1] 값을 사용해주면 됩니다.

따라서 이때는 dp[i-1][j]와 dp[i][j-1] 중에 작은 값에 새로운 문자를 더하여 늘어난 개수인 1을 더한 값을 이용합니다.



위의 두가지 경우를 정리해보면 dp[i][j]의 점화식은 다음과 같이 정의할 수 있습니다.
```text
dp[i][j]={ dp[i−1][j−1]+1                  if A[i]=B[j]
           min(dp[i−1][j],dp[i][j−1])+1    if A[i]!=B[j]
```

​
  
다음과 같이 첫 번째 문자열의 길이가 3이고 두 번째 문자열의 길이가 4일때 가능한 최단 supersequence의 길이를 구해봅시다.



먼저 DP에서 가장 중요한 것은 초기 조건입니다. 피보나치 수열 문제에서 처음 두 항이 1이라는 초기 조건 덕분에 뒤의 값을 올바르게 채울 수 있었던 것처럼, 점화식에 따라 dp 배열에 올바른 값이 채워지기 위해서는 초기에 값을 잘 적어줘야 합니다.

먼저 dp[1][1]은 두 문자가 일치하는 경우에는 1, 아니라면 2가 됩니다.

최상단의 경우 두 문자가 일치하면 j가 되고, 그렇지 않다면 현재 문자를 더 추가해줘야 하므로 dp[1][j - 1] + 1이 됩니다.
최좌측 열의 경우 두 문자가 일치하면 i가 되고, 그렇지 않다면 현재 문자를 더 추가해줘야 하므로 dp[i - 1][1] + 1이 됩니다.



나머지 문자열을 순회하며 순서대로 값을 채우는 과정은 점화식을 이용하면 됩니다. 두 문자가 일치하는 경우에는 대각선 방향에 있는 값에 1을 더해주고, 그렇지 않은 경우에는 위 왼쪽 중 작은 값에 1을 더하여 적어주면 됩니다.



만약 DP 관련 String Matching 유형에서 아직 DP 테이블에 숫자를 어떤 순서로 어떻게 채워야 하는지를 잘 모르신다면, Novice High 문제집의 DP 관련 String Matching 유형에서 Table 채우기를 공부하시고 나서 이 글을 읽는 것을 추천드립니다.

이렇게 dp 배열을 전부 채우고 나면, 결국 구하고자 하는 답은 첫 번째 문자열과 두 번째 문자열을 모두 끝까지 고려했을 때 얻을 수 있는 supersequence의 최단 길이이기 때문에 첫 번째 문자열의 길이를 len_A, 두 번째 문자열의 길이를 len_B이라고 했을 때 dp[len_A][len_B] 값이 답이 됩니다.

### 개념 설명에 대한 해설

이 문제에서 정의를 잘 확인해야 한다. `두 문자열을 모두 부분 문자열로 하는 문자열 중 길이가 가장 짧은 문자열을 구해보려 합니다. ` 이니까 두 문자열 모두 사용되면서 길이가 가장 짧은 문자열을 구해야 한다.

두 문자열이 모두 다르다면 단순하게 매번 문자열 차례마다 + 1을 더해주면 될 것이다.

하지만 부분 문자열로 하는 문자열의 길이가 더 짧아지는 순간이 공통 문자인 경우에 발생한다. 이 경우를 따져주기 위해서 DP[][]로 값을 저장하면서 + 1씩 더해준다.

문자열이 다르다면 단순하게 각 문자열의 부분 문자열 중 더 짧은 문자열을 선택해서 + 1을 해주면 된다. ex) aa, aab에서 aa 선택

```text 
dp[i][j] = min(dp[i−1][j],dp[i][j−1])+1    (if A[i]!=B[j])
```

그런데 공통 문자라면 각 문자열 모두 공통된 문자이므로 둘 다 이전의 부분 문자열로 하는 문자열의 길이에 + 1 해주면 된다.

```text
dp[i][j] = dp[i−1][j−1]+1                  (if A[i]==B[j])
```
           
