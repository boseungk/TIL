## [Java] 나무높이

[나무높이](https://swexpertacademy.com/main/solvingProblem/solvingProblem.do)

## 처음 풀이
```java
public class Solution {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for(int t = 1; t <= T; t++) {
			int n = Integer.parseInt(br.readLine());
			int[] trees = new int[n];
			StringTokenizer st = new StringTokenizer(br.readLine());
			for(int i = 0; i < n; i++) {
				trees[i] = Integer.parseInt(st.nextToken());  
			}
			int maxHeight = 0;
			for(int i = 0; i < n; i++) {
				maxHeight = Math.max(maxHeight, trees[i]);
			}
			int oddNum = 0;
			int evenNum = 0;
			for(int i = 0; i < n; i++) {
				int targetHeight = maxHeight - trees[i];
				if(targetHeight % 2 == 1) {
					oddNum += 1;
					evenNum += (targetHeight / 2);
				}else {
					evenNum += (targetHeight / 2);
				}
			}
			int answer = 0;
			for(int i = 0; i < evenNum; i++) {
				if(evenNum + 1 == oddNum) {
					answer = oddNum * 2 - 1;
					break;
				}else if(evenNum == oddNum) {
					answer = oddNum + evenNum;
					break;
				}
				evenNum = evenNum - 1;
			 	oddNum = oddNum + 2;
			}
			System.out.println("#" + t + " " + answer);
		}
	}
}
```

이 부분에서

```java

for(int i = 0; i < evenNum; i++) {
    if(evenNum + 1 == oddNum) {
        answer = oddNum * 2 - 1;
        break;
    }else if(evenNum == oddNum) {
        answer = oddNum + evenNum;
        break;
    }
    evenNum = evenNum - 1;
    oddNum = oddNum + 2;
}
```

for문에 break가 자꾸 필요해서 뭔가 분리시켜야 할 것 같은 느낌을 받았다. 

한 코드 덩어리는 하나의 관심사를 가지도록 설계해야 할 것 같다.

그리고 그리디로 접근하다가 예시를 하나씩 들어서 if문을 세우다가 경우의 수를 빠뜨렸다.

1. 변수를 명확히 정하고 
2. 홀수, 짝수 관점에서 1. 크거나 2. 같거나 3. 작거나 이런식으로 빠짐없이 접근했으면 모든 경우의 수를 따져줬을 수 있었을 것이다.

## 2. 그리디 풀이

```java
public class Solution {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for(int t = 1; t <= T; t++) {
			int n = Integer.parseInt(br.readLine());
			int[] trees = new int[n];
			StringTokenizer st = new StringTokenizer(br.readLine());
			for(int i = 0; i < n; i++) {
				trees[i] = Integer.parseInt(st.nextToken());  
			}
			int maxHeight = 0;
			for(int i = 0; i < n; i++) {
				maxHeight = Math.max(maxHeight, trees[i]);
			}
			int oddNum = 0;
			int evenNum = 0;
			for(int i = 0; i < n; i++) {
				int targetHeight = maxHeight - trees[i];
				if(targetHeight % 2 == 1) {
					oddNum += 1;
					evenNum += (targetHeight / 2);
				}else {
					evenNum += (targetHeight / 2);
				}
			}
            // 하나의 관심사: |짝수의 개수 - 홀수의 개수| <= 1로 분리
			while (evenNum > oddNum + 1) {
				evenNum--;
				oddNum += 2;
			}

			int answer = 0;
			if (oddNum > evenNum) {
				answer = oddNum * 2 - 1;
			} else {
				answer = evenNum * 2;
			}
			
			System.out.println("#" + t + " " + answer);
		}
	}
}
```