## 트리에서 공 떨어뜨리기

### 문제

루트가 있는 이진 트리가 주어지고, 이 이진 트리에서 공을 루트 노드에서 떨어뜨리고자 합니다.

공은 다음과 같은 규칙에 따라 떨어집니다.

현재 노드의 자식 노드가 한 개라면 해당 자식 노드로 전달됩니다.
현재 노드의 자식 노드가 두 개라면, 현재 노드의 왼쪽 서브트리에 있는 모든 공의 수가 오른쪽 서브트리에 있는 모든 공의 수보다 작거나 같을 경우, 왼쪽 자식 노드로 전달됩니다. 그 외의 경우에는 오른쪽 자식 노드로 전달됩니다.
현재 노드의 자식 노드가 없다면 그 자리에서 멈춥니다.
따라서, 공은 항상 자식 노드가 없는 리프 노드에서 멈추게 됩니다. 이제 이러한 공을 차례대로 k개를 떨어뜨리고자 합니다.

k번째 공이 어느 노드에서 멈출지 계산하는 프로그램을 작성해보세요.

주어지는 트리는 항상 올바른 이진 트리임이 보장되며, 루트 노드는 항상 1번 노드입니다.

입력 형식
첫 번째 줄에 트리의 노드의 수 n이 주어집니다.

두 번째 줄부터 n 개의 줄에 각 노드의 왼쪽 자식노드와 오른쪽 자식노드가 공백을 두고 차례대로 주어집니다.

만약 -1이 나온다면 해당 위치에는 자식노드가 존재하지 않는다는 것입니다.

마지막 줄에는 k가 주어집니다.
```
1 ≤ n ≤ 200,000

2 ≤ 노드의 번호 ≤ n

1 ≤ K ≤ 10**18
 ```

출력 형식
k번째 공이 멈추는 노드의 번호를 출력합니다.

입출력 예제
예제1
입력:
```
5
2 3
-1 -1
4 5
-1 -1
-1 -1
5
```
출력:
```
2
```
### 해설

시뮬레이션 돌리려는 이유? -> 리프 노드에서 쌓인 공의 개수 필요 -> but k가 최대 10**18이므로 시뮬레이션은 불가능함 -> k의 위치 이동(dfs)과 동시에 결정

예를 들어
 root (4개 쌓였으므로 5번째 공이 어디로 갈지 판단? -> 왼쪽)
 /  \ 
2    x (2 -> 3개 쌓이고 리프 노드이므로 종료)
    / \
   1   1

 root (5개 쌓였으므로 6번째 공이 어디로 갈지 판단? -> 오른쪽)
 /  \ 
3    x (2개 쌓였으므로 6번째 공이 어디로 갈지 판단? -> 왼쪽)
    / \
   1   1 (1 -> 2개 쌓이고 리프 노드이므로 종료)

일반화하면 root에서 num - 1이 child 노드에 쌓인 공 개수의 합으로 왼쪽/오른쪽 결정하므로 홀짝을 활용

```python

import sys
sys.setrecursionlimit(200000)

def dfs(num, node):
    global answer
    if left_node[node] == -1 and right_node[node] == -1:
        answer = node
        return
    if left_node[node] == -1:
        dfs(num, right_node[node])
    elif right_node[node] == -1:
        dfs(num, left_node[node])
    if (num) % 2 == 1:
        dfs((num + 1) // 2, left_node[node])
    else:
        dfs(num // 2, right_node[node])

n = int(input())
arr = [tuple(map(int, input().split())) for _ in range(n)]
k = int(input())
left_node = [0] * (n + 1)
right_node = [0] * (n + 1)
for i in range(1, n + 1):
    left_node[i], right_node[i] = arr[i - 1]
answer = 0
dfs(k, 1)
print(answer)

```